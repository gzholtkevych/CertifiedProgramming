# Безтипове лямбда-числення (огляд)

Лямбда-числення є базою для **Rocq Prover**, який ми використовуємо як платформу сертифікованого програмування.

## Синтаксис лямбда-числення

Синтаксично лямбда-числення є доволі простою мовою.

### Словник лямбда-числення

**Словник лямбда-числення** складається з двох частин

- зліченної множини сутностей, які називаються ***змінними*** і які є ***алгоритмічно розрізненими***, тобто ми маємо формальну процедуру відповіді на питання чи є дві будь-які змінні рівними чи ні;
- чотирьох спеціальних символів "$(\ )\ \lambda\ .$", які **не є змінними**.

### Терми лямбда-числення

Основними об'єктами лямбда-числення є вирази лямбда-числення, яі називаються ***лямбда-термами*** або просто ***термами***.

Лямбда-терми будуються за такими синтаксичними правилами (за допомогою таких конструкторів):

- (*atomic term constructing*): будь-яка змінна є термом;
- (*application term constructing*): для будь-яких двох вже побудованих термів $t_1$ та $t_2$, $(t_1\,t_2)$ є термом;
- (*abstraction term constructing*): для будь-якої змінної $x$ та вже побудованого терму $t$, $(\lambda\,x\,.\,t)$ є термом. 

Тобто, абстрактний синтаксис лямбда-числення визначається такими формальними правилами

```math
\begin{array}{lc}
(\textsf{atomic term constructing}): & \dfrac{x:V}{x:\Lambda} \\[12px]
(\textsf{application term constructing}): & \dfrac{t_1:\Lambda\quad t_2:\Lambda}{(t_1\,t_2):\Lambda} \\[12px]
(\textsf{abstraction term constructing}): & \dfrac{x:V\quad t:\Lambda}{(\lambda\,x\,.\,t):\Lambda}
\end{array}
```

де $V$ є множиною змінних, а $\Lambda$ - множиною термів.

<!-- Тут планується додати текст про синтаксичне дерево лямбда-терму -->

### Альфа-конверсія лямбда-термів

Давайте розглянемо дві формули

```math
\sum\limits_{k=1}^nk^2\qquad\textsf{та}\qquad\sum\limits_{j=1}^nj^2
```

Хоча ці формули не є тотожними, зазвичай ми вважаємо ці формули рівними.

Інший приклад. Код

```python
def f(x):
    return x ** z
```

не є тотожним коду

```python
def f(y):
    return y ** z
```

проте вони є специфікаціями однієї функції.

Ці два приклади є подібними, а саме вони відрізняються змінною, яка не має сенсу поза формулою чи програмою.
Таку змінну можна назвати ***зв'язаною*** змінною.<br/>
Зв'язані змінні можна перейменовувати (не порушуючи, правда, деякого простого правила) без зміни сенсу формули чи програми.

На відміну від цього змінні $n$ у першому прикладі та `y` у другому не є зв'язаними, а їх перейменування впливане на сенс формули або програми.

Лямбда-числення моделює цей ефект формально.

Будемо казати, що ***змінна*** $x$ ***використовується у термі*** $t$, якщо

- або $t\equiv x$,
- або $t\equiv(t_1\,t_2)$ та $x$ використовується або в $t_1$ або в $t_2$,
- або $t\equiv(\lambda\,y\,.\,t_1)$ та $y\equiv x$ або $x$ використовується в $t_1$.



## Обчислення як спрощення (редукція) лямбда-термів

### Бета-редукція термів



### Ета-редукція



## Нормальна форма лямбда-термів



## Лямбда-числення як система програмування


