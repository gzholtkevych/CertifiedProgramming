<H1><b>ЛЕКЦІЯ 2. Задача розробки простого програмованого стекового обчислювача</b></H1>

Знайомство з технологією сертифікованого програмування почнемо з мініпроєкту, що демонструє сертифіковану розробку простого програмованого стекового обчислювача.

<details><summary><H2>Завдання мініпроєкту</H2></summary>

Маємо арифметичні вирази, які оперують з натуральними константами за допомогою бінарних операцій додавання і множення.

Абстрактний синтаксис мови арифметичних виразів визначається наступними правилами

<table width=800px height=150px align="center">
<tr><td align="center">
$\mathtt{binop}\textbf{ is either }\mathtt{plus}\textbf{ or }\mathtt{mult}$</td></tr><tr><td align="center">
$\dfrac{n\textbf{ is a natural number}}{\mathtt{const}\ n\textbf{ is an arithmetic expression}}$</td></tr><tr><td align="center">
$\dfrac{e_1,e_2\textbf{ are arithmetic expressions and }bop\textbf{ is a binop}}{\mathtt{term}\ bop\ e_1\ e_2\textbf{ is an arithmetic expression}}$</td></tr>
</table>

Семантичним значенням арифметичного виразу будемо вважати натуральне число, яке є результатом обчислення цього виразу.

Розглянемо також обчислювач, пам'ять якого представляє собою стек натуральних чисел.

Програма обчислювача є послідовністю команд, кожна з яки є або
- команда $\mathtt{save}\ n$, яка проштовхує $n$ в стек, або
- команда $\mathtt{eval}\ bop$, яка виконує операцію, що визначається значенням $bop$ над двома числами з вершини стеку, видалючі їх і проштовхуючи результат в стек.
Зрозуміло, що ця команда може виконуватися тільки у випадку, якщо у стеку зберігається не менше двох чисел.

Задачею є побудова програми, яка приймає арифметичний вираз та повертає програму для описаного обчислювача, яка обчислює цей арифметичний вираз.

</details>

<details><summary><H2>Необхідні типи даних для представлення арифметичних виразів</H2></summary>

Спроєктуємо та специфікуємо ці типи даних, використовуючи The Coq Proof Assistant.

Першим нашим кроком буде специфікація типу даних `binop`, призначеного для представлення символів бінарних операцій:

```
Inductive binop := plus | mult.
```
Це визначення вводить новий тип з іменем `biniop`, в якому живуть лише дві константи `plus` та `mult`.
Формальною гарантією того, що ніякі інші сутності окрім `plus` та `mult` не живуть в `biniop` представляється такими твердженнями

```
binop_ind  : forall P : binop -> Prop, P Plus -> P Mult -> forall b : binop, P b
binop_rec  : forall P : binop -> Set, P Plus -> P Mult -> forall b : binop, P b
binop_rect : forall P : binop -> Type, P Plus -> P Mult -> forall b : binop, P b
```
Саме команда `Inductive` забезпечує автоматичне генерування цих гарантій, відомих як принципи індукції.

Тепер ми можемо представити абстрактний синтаксис арифметичних виразів, використовуючи The Coq Proof Assistant.

```
Inductive expr :=
  Const : nat -> expr
| Binop : binop -> expr -> expr -> expr.
```

</details>
