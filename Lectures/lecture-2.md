<H1><b>Тема: Вступ до лямбда-числення</b></H1>

Типізоване лямбда-числення є математичним підґрунтям майже всіх розвинених програмних інструментів верифікації програмного забезпечення класу Proof Assistant.

Виходячи з цього даємо короткий огляд безтипового лямбда-числення, а потім різних типізацій цього числення.

## Безтипове лямбда-числення

Будь-яке числення утворюється мовою виразів (або термів) та правилами спрощення цих виразів.
Правила спрощення визначають уніфікований механізм виведення (обчислень) у цьому численні.

### Синтаксис безтипого лямбда числення

**Словник** безтипого лямбда числення включає

- *зліченну* (**!важливо**) множину $\symbf{V}$ атомарних сутностей, що звуться змінними, а також
- спеціальні символи, що **не входять** до $\symbf{V}$ - $\uplambda$; дужка, що відкривається; дужка, що закривається; крапка.

**Cинтаксис** безтипого лямбда числення визначається трьома правилами побудови термів, множина яких позначається через $\symbf{\Lambda}$

```math
\begin{eqnarray}
& \frac{x\in\symbf{V}}{x\in\symbf{\Lambda}} & -\text{конструювання атомів} \\
& \frac{T_1\in\symbf{\Lambda}\quad T_2\in\symbf{\Lambda}}{(T_1\,T_2)\in\symbf{\Lambda}} & -\text{конструювання застосувань} \\
& \frac{x\in\symbf{V}\quad T\in\symbf{\Lambda}}{(\uplambda\,x\mathop{.}T)} & -\text{конструювання абстракцій}\end{eqnarray}
```

>Кожний терм можна представити його синтаксичним деревом.
>Наприклад, терм $$(\uplambda\ x\mathop{.}(\uplambda\ y\mathop{.}(\uplambda\ z\mathop{.}((x\ z)\ (y\ z)))))$$ має наступне синтаксичне дерево

```mermaid
---
title: Приклад синтаксичного дерева
---
graph TD
    A[/x\] --> B[/y\]
    B --> C[/z\]
    C --> D{ }
    D --> E{ }
    D --> F{ }
    E --> G((x))
    E --> H((z))
    F --> I((y))
    F --> J((z))
```

>Трапецеідальні вузли цього дерева відповідають конструванню абстракції за змінною, яка є міткою вузла.<br/>
>Ромбовидніні вузли цього дерева відповідають конструктору застосування.<br/>
>Листя дерева зображені колами; вони відповідають конструюванню атома за змінною, яка є міткою вузла.

Кожне входження змінної в терм (лист синтаксичног дерева помічений цією змінною) може бути або **вільним**, або **зв'язаним**.

Неформально кажучи, входження змінної в терм

- є вільним, якщо на шляху від листа, що відповідає входженню змінної, до кореня дерева немає жодного вузла поміченого цією змінною,
- є зв'язаним, якщо на шляху від листа, що відповідає входженню змінної, до кореня дерева є вузол помічений цією змінною.

В наведеному вище прикладі всі входження всіх змінних є зв'язними.

Для терму $((x\ (\uplambda\ x\mathop{.}(x\ y)))\ x)$ синтаксичне дерево має вигляд

```mermaid
---
title: Вільні та зв'язані змінні
---
graph TD
    A{ } --> B{ }
    A --> C((x))
    B --> D((x))
    B --> E[/x\]
    E --> F{ }
    F --> G((x))
    F --> H((y))
```

Тобто, перше та третє входження змінної $x$ у цей терм є вільними, друге - зв'язаним.
Єдине входження змінної $y$ у цей терм є вільним.

### Перейменування змінних

Давайте для наведеного прикладу замінемо змінну $x$ у другому входженні та відповідному "зв'язуючому" вузлі на $z$, отримаємо


```mermaid
graph TD
    A{ } --> B{ }
    A --> C((x))
    B --> D((x))
    B --> E[/z\]
    E --> F{ }
    F --> G((z))
    F --> H((y))
```

Осьаннє дерево є синтаксичним деревом терму $((x\ (\uplambda\ z\mathop{.}(z\ y)))\ x)$.

Ці два терми мають ізоморфні синтаксичні дерева з однаковими мітками для вільних входжень змінних і відрізняються лише мітками
зв'язуючих вузлів та відповідних зв'язаних змінних.

Це дає підставу не розрізняти такі терми, точніше вважати їх еквівалентними.
Зазначена еквівалентність у лямбда-численні називається **альфа-конгруенцією**.

Операція перейменування зв'язаних змінних, яку ми застосували на прикладі, називається **перейменуванням** або
альфа-конверсією.

Важливим обмеженням операції перейменування є вимога збереження вільних входжень змінних в її результаті.
Тото,

>якщо вузол піддерева синтаксичного дерева терму, до якого застосовується операція перейменування, є вільним у піддереві, тоді
цей вузол має залишитися вільним у піддереві після перейменування.

Зазначене обмеження не порушується у разі, якщо нова змінна обирається серед змінних, які не використовуються в термі.
Такі змінні називаються **свіжими змінними** терму.

Зважаючи на нескінченність множини змінних, два альфа-конгуентні терми завжди можна привести до одного терма за допомогою
переймувань.
Насправді вірно і зворотнє твердження.

Таким чином,
>Два терми є альфа-конгуентними тоді і тільки тоді, коли їх можна привести до одного й того самого терму за допомогою
скінчених посдідовностей перейменувань.

### Бета-редукція

Перетворення бета редукції моделює процес обчислення функції.

Це перетворення початково застосовується до термів виду $((\uplambda\ x\mathop{.}M)\ N)$, де $M,N$ є термами.
Ефлш терми називаються **редексами** (a ***red***ucible ***ex***pression).
Це перетворення можна проілюструвати наступною схемою:

Терм виду

```mermaid
graph TD
    A{ } ---> B[/x\]
    A ---> N
    B ---> M
    subgraph M
        C[ ] ---> D((x))
        C ---> E((y))
        C ---> F((x))
    end
```

претворюється на терм

```mermaid
graph TD
    subgraph M
        C[ ] ---> M1[N]
        C ---> y
        C ---> M2[N]
    end
```

Тобто береться терм $M$ і замість вільних входжегб змінної $x$ підставляється терм $N$, але при цьому вільні ходження змінних
в терму $N$ мають залишитися вільними в новому термі.
Це досягається таким перейменуванням зв'язаних змінних в термі $M$, яке забезпечує диз'юнктність множини зв'язаних змінних $M$
з множиною вільних змінних $N$.  

### Ета-конверсія

Перетворення ета-конверсії забезпечує принцип інтенсиональності для функцій:

> дві функції $f,g:X\to Y$ є рівними, якщо $f(x)=g(x)$ для будь-якого $x\in X$.

Припустимо, що атомарний терм $f$ моделює функцію і розглянемо терм $G=(\uplambda\ x\mathop{.}(f\ x))$.<br/>
Тоді результатом застосування $f$ до терму $X$ буде $(f\ X)$,<br/>
а результатом застосування $G$ до терму $X$ буде $((\uplambda\ x\mathop{.}(f\ x))\ X)\to_\beta(f\ X)$.

Зрозуміло, що терми $f$ та $G$ не є альфа-конгруєнтними, проте вони мають однакову функціональну поведінку, це обґрунтовує таке
правило перетворення

> $(\uplambda\ x\mathop{.}(M\ x))\to_\eta M$ за умови, що $x$ не є вільною у $M$.

###  Обчислювальна рівність термів

Правила перетворення дають нам можливість визначити відношення обчислювальної рівності термів у два кроки.

Перший крок:

> Терм $M$ **редукується** до терму $N$, якщо
> - ці терми є альфа-конгруєтними, або
> - існує скінченна послідовність бета-редукцій та ета-конверсій, яка перетворює $M$ на $N$.

**Теорема Черча-Росера**
>Якщо терм $M$ редукується до будь-яких двох термів $M1$ та $M2$, тоді існує терм $N$ такий, що $M1$ редукується до $N$ і $M2$
редукується до $N$.

```mermaid
graph LR
    M[M] ===> M1[M1]
    M ===> M2[M2]
    M1 -..-> N[N]
    M2 -..-> N[N]
```

**Висновки з теореми Черча-Росера**
>1. Якщо терм можна привести до нормальної форми, тоді ця нормальна форма є єдиною з точність до альфа-конгруентності.
>2. Якщо відношення між термами визначається так: $M$ та $N$ знаходяться в цьому відношенні тоді і тільки тоді, коли існує терм,
до якого редукуються обидва терми $M$ та $N$, тоді це відношення я еквівалентністю.

Еквівалентність, визначена у другому висновку називається ***обчислюваною рівністю*** термів.

## Просто типізоване лямбда числення

### Аномалії редукування

**Петля.**
Розглянемо терм $\Omega_2=((\uplambda\ x\mathop{.}(x\ x))(\uplambda\ x\mathop{.}(x\ x)))$.

Він є редексом, редукування якого дає $\Omega_2$.<br/>
Тобто процес ніколи не закінчується.

**Нескінченний шлях редукції.**
Розглянемо терм $\Omega_{3,2}=((\uplambda\ x\mathop{.}((x\ x)\ x))(\uplambda\ x\mathop{.}((x\ x)\ x))$, тоді процес редукції можна
представити так<br/>
$$\Omega_{3,2}\to_\beta\Omega_{3,3}=(((\uplambda\ x\mathop{.}((x\ x)\ x))(\uplambda\ x\mathop{.}((x\ x)\ x)))
(\uplambda\ x\mathop{.}((x\ x)\ x)))\to_\beta\Omega_{3,4}\to_\beta\ldots\to_\beta\Omega_{3,n}\to_\beta\ldots$$

**Нескінченний шлях редукції у нормалізуємому терм.**
Розглянемо терм $((\uplambda\ x\mathop{.}(\uplambda\ y\mathop{.}y))\Omega_{3,2})$. Якщо редукувати внутрішний редекс, то послідовно
будемо отримувати терми $((\uplambda\ x\mathop{.}(\uplambda\ y\mathop{.}y))\Omega_{3,3})$,
$((\uplambda\ x\mathop{.}(\uplambda\ y\mathop{.}y))\Omega_{3,4})$ і т.д.<br/>
У разі ж редукування зовнішнього редексу зразу отримаємо нормальну форму $(\uplambda\ y\mathop{.}y)$.

### Мова простих типів

Словник цієї мови складається з

- не більш ніж зліченої множини $\symbf{T}_{0}$ *атомарних сутностей які називають базовими, атомарними, а іноді скалярними, типами*;<br/>
**Зауваження.** Не можна говорити про те що ці сутності щось містять - вони не є множинами, вони є просто іменами, мітками);
- спеціальні символи - стрілка спрямова х зліва на право, а також відкриваюча та закриваюча дужки

Множина виразів цієї мови $\symbf{T}$, які називають ***типами***, будується за допомогою всього двох синтаксичних правил:

```math
\begin{eqnarray}
&\dfrac{A\in\symbf{T}_0}{A\in\symbf{T}} &\text{- правило побудови атомарного типу} \\
&\dfrac{\alpha\in\symbf{T}\quad\beta\in\symbf{T}}
 {\left(\alpha\rightarrow\beta\right)\in\symbf{T}} &\text{- правило побудови функціонального типу}
\end{eqnarray}
```

### Типізація термів

***Відношення типізації*** є відношенням між термами і типами, яке позначається як $M:\alpha$ і читається "терм $M$ має тип $\alpha$", або
"терм $M$ мешкає у типі $\alpha $".

Тип можна приписувати ***комбінаторам*** (термам без вільних змінних), а тип терма з вільними змінними, очевидно, має залежати від типу
атомарних підтермів, що відповідають вільним змінним терма.

Останнє призводить для поняття ***припущення типізації***: припущенням типізації називають пару $x:\alpha$, де $x$ є змінна, а $\alpha$ є тип.

Множину припущень типізації, в якій жодні два припущення не можуть мати спільнц змінну, ***контекстом***: $x_{1}:\alpha_{1},\dotsc,x_{n}:\alpha_{n}$
є контекстом, якщо $1\leq i\neq j\leq n$ забезпечує $x_i\neq x_j$.<br/>
**Зауваження.**
Контекст типізації можна розглядати як відображення (словник) скінченної множини змінних у множину типів.

***Судженням типізації*** є вираз виду $\Gamma\vdash M:\alpha$, де $\Gamma$ є контекстом, $M$ - термом, а $\alpha$ - типом.
Цей вирах читається як "в контексті $\Gamma$ терм $M$ є мешканцем типу (має тип) $\alpha$".

**Правила типізації**
призначенні для отримання суджень типізації є наступними:

```math
\begin{eqnarray}
&\dfrac{\Gamma\vdash M:\alpha}{\Gamma,\Delta\vdash M:\alpha } &\text{- правило послаблення. Tут }\Delta\text{ є контекстом, що не суперечить }\Gamma \\
&x:\alpha\vdash x:\alpha &\text{- правило тавтології} \\
&\dfrac{\Gamma\vdash M:\alpha\rightarrow\beta\quad\Gamma\vdash N:\alpha}{\Gamma\vdash(M N):\beta} &\text{- правило застосування} \\
&\dfrac{\Gamma,x:\alpha\vdash M:\beta}{\Gamma\vdash(\uplambda\ x\mathop{.}M:\alpha\rightarrow\beta} &\text{- правило абстракції}
\end{eqnarray}
```

**Приклад.**

Програмна функція

```python

def id(x: int) -> int:
    return x
```

моделюється комбінатором $\mathbf{I}=\uplambda\ x\mathop{.}x$, для якого $\vdash\mathbf{I}:\mathtt{int}\rightarrow\mathtt{int}$.</br>
Дійсно,

- судження $x:\mathtt{int}\vdash x:\mathtt{int}$ є коректним (правило тавтології)
- судження $(\uplambda\ x\mathop{.}x):\mathtt{int}\rightarrow\mathtt{int}$ є результатом застосування правила абстракції до попереднього судження

Зауважте, що в цьому прикладі судження $\vdash\mathbf{I}:\mathtt{int}\rightarrow\mathtt{int}$ не має контексту.

### Властивості простої типізації


